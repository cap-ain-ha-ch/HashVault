package com.github.tmpstpdwn;

import java.security.MessageDigest;
import java.security.SecureRandom;
import java.nio.charset.StandardCharsets;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;

class Vault {

    public enum BytesType {
        // Enums in Java are special types that represent a fixed set of constants.
        SALT_BYTES(16),
        IV_BYTES(12);
        // A private field to hold the integer value associated with each constant
        private final int value;

        /*Constructor for the enum.
        Each enum constant (SALT_BYTES, IV_BYTES) calls this constructor
        with its specific integer value (16 or 12).*/
        BytesType(int value) {
            this.value = value;
        }
        /* Public getter method to return the integer value associated
        with an enum constant.
        Example: BytesType.SALT_BYTES.getValue() -> 16*/
        public int getValue() {
            return value;
        }
    }

    private static final int GCM_TAG_LENGTH = 128;
    private static final int ITERATIONS = 696_969;
    private static final int KEYLENGTH = 256;

    private static final SecureRandom secureRandom = new SecureRandom();

    public static byte[] generateBytes(BytesType bytesType) {
    /*
    Generates a random sequence of bytes of a specified length. 
    As parameters, bytesType An enum value (BytesType) specifying the length of bytes to generate.
    For example, SALT_BYTES or IV_BYTES.
    On return; A byte array filled with cryptographically secure random values.
    
    This method works as follows:
    
    1. Creates a new byte array with length determined by bytesType.getValue().
    2. Uses the SecureRandom instance (secureRandom) to fill the array with random bytes.
    3. Returns the generated byte array.
    */
        byte[] bytes = new byte[bytesType.getValue()];
        secureRandom.nextBytes(bytes);
        return bytes;
    }

    public static byte[] getKeyBytes(String password, byte[] salt) throws Exception {
        try {
            // Create a key specification using the password, salt, number of iterations, and key length
            PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), salt, ITERATIONS, KEYLENGTH);
            // Get an instance of PBKDF2 with HMAC-SHA256 algorithm
            SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
            // Generate the secret key based on the specification and get its byte array
            byte[] hash = factory.generateSecret(spec).getEncoded();
            // Return the derived key bytes
            return hash;
        } catch (Exception e) {
            // If any error occurs during key derivation, throw a generic exception with a message
            throw new Exception("Failed to generate key");
        }
    }

    public static SecretKey getAESKey(String password, byte[] salt) throws Exception {
        // Derive a cryptographic key from the password and salt using PBKDF2
        byte[] keyBytes = getKeyBytes(password, salt);
        // Create an AES SecretKey from the derived key bytes
        // SecretKeySpec allows using a raw byte array as a key for a specific algorithm ("AES")
        return new SecretKeySpec(keyBytes, "AES");
    }

    public static byte[] encrypt(String plaintext, SecretKey key) throws Exception {
        try {
            // Generate a random initialization vector (IV) for AES-GCM
            byte[] iv = generateBytes(BytesType.IV_BYTES);
            // Create GCM parameter specification using IV and tag length
            GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
            // Get a Cipher instance for AES in GCM mode with no padding
            Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            // Initialize the cipher in encryption mode with the key and GCM parameters
            cipher.init(Cipher.ENCRYPT_MODE, key, spec);

            // Encrypt the plaintext (converted to UTF-8 bytes) and get ciphertext
            byte[] ciphertext = cipher.doFinal(plaintext.getBytes(StandardCharsets.UTF_8));

            // Combine IV and ciphertext into a single byte array for output
            byte[] result = new byte[iv.length + ciphertext.length];
            System.arraycopy(iv, 0, result, 0, iv.length);
            System.arraycopy(ciphertext, 0, result, iv.length, ciphertext.length);

            // Return the combined IV + ciphertext
            return result;
        } catch (Exception e) {
            throw new Exception("Encryption failed");
        }
    }

    public static String decrypt(byte[] combined, SecretKey key) throws Exception {
        try {
            // Extract the IV from the beginning of the combined array
            byte[] iv = new byte[BytesType.IV_BYTES.getValue()];
            // The rest of the array is the actual ciphertext
            byte[] ciphertext = new byte[combined.length - iv.length];

            // Copy IV from combined array
            System.arraycopy(combined, 0, iv, 0, iv.length);
            // Copy ciphertext from combined array
            System.arraycopy(combined, iv.length, ciphertext, 0, ciphertext.length);

            // Create GCM parameter specification using IV and tag length
            GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
            // Get a Cipher instance for AES in GCM mode with no padding
            Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            // Initialize the cipher in decryption mode with the key and GCM parameters
            cipher.init(Cipher.DECRYPT_MODE, key, spec);
            // Decrypt the ciphertext
            byte[] decrypted = cipher.doFinal(ciphertext);
            // Convert decrypted bytes back to a UTF-8 string
            return new String(decrypted, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new Exception("Decryption failed: Invalid ciphertext or key");
        }
    }

}
